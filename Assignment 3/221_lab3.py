# -*- coding: utf-8 -*-
"""221 lab3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17XKBqA-cvoyYwj45Q4pJXu25UvRAOL70
"""

class Graph:
  def __init__(self, N= None, E=None):
    self.nodes = N
    self.edges = E

  #Task 1a method
  #adj matrix 
  def matrixImp(self,li):
    list2 = []
    list3 = []
    for item in li[2:]:
      list2.append(item.split())

    #converting str to int
    for lists in list2:
      i = 0
      for item in lists:
        lists[i] = int(lists[i])
        i += 1
      list3.append(tuple(lists))

    #making the final matrix
    matrix = [[0]*self.nodes for i in range(self.nodes)]
    for tup in list3:
      matrix[tup[0]-1][tup[1]-1] = 1
    return matrix


  #Task 1b method
  #adj list
  def listImp(self, li):
    result = {}
    c = 0
    for lists in li: 
      if li[c][1:] == []:
        result[li[c][0]] = []
      else:
        result[li[c][0]] = li[c][1:]
      c += 1
    return result



  #Task 2(BFS) method
  visitedBFS = []
  q = []
  
  def BFS(self, graph, node, endPoint, visited, q):

    self.visitedBFS.append(node)
    self.q.append(node)


    while self.q != []:
      qHead = self.q.pop()
      if qHead == endPoint:
        return self.visitedBFS
      else:
        for nbr in graph[qHead]:
          if nbr not in visited:
            self.visitedBFS.append(nbr)
            self.q.append(nbr)

  #method for finding the shortest path
  def shortestPath(self, graph, node, endPoint):
    result = []
    for key, val in graph.items():
      if key == endPoint:
        result.append(key)
        return result
      else:
        if key not in result:
          result.append(key)
          for nbr in val:
            if nbr not in result:
              if endPoint in val:
                result.append(endPoint)
                return result
              else:
                result.append(nbr)
            else:
              if endPoint in val:
                result.append(endPoint)
                return result
              else:
                result.append(nbr)
        else:
          for nbr in val:
            if nbr not in result:
              if endPoint in val:
                result.append(endPoint)
                return result
              else:
                result.append(nbr)
            else:
              if endPoint in val:
                result.append(endPoint)
                return result
              else:
                result.append(nbr)

  #Task 3(DFS)
  visitedDFS = []
  printed = []
  resultDFS = []
  
  def DFS_visit(self,graph, node, visited, printed, result):
    visited.append(node)
    printed.append(node)
    for nbr in graph[node]:
      if nbr not in visited:
        self.DFS_visit(graph, nbr, visited, printed, result)
  
  def DFS(self, graph, endPoint, visited, printed, result):
    for node in graph.keys():
      if node not in visited:
        self.DFS_visit(graph, node, visited, printed, result)
    for node in printed:
      if node == endPoint:
        result.append(node)
        return result
      result.append(node)




  
##Driver codes

#adj matrix 
f1 = open('input1.txt','r')
list1 = f1.readlines()
node = int(list1[0])
edge = int(list1[1])
Graph1 = Graph(node, edge)
out1 = Graph1.matrixImp(list1)
out1 = f'Matrix implementation: {out1}'
o1 = open('output1.txt','w')
o1.write(out1)


#adj list
f2 = open('input2.txt','r')
info = f2.readlines() #contains all the info in the input file in list format
lines = []
for item in info[1:]:
  lines.append(item.split())
node = int(info[0])
Graph2 = Graph(node)
out2 = Graph2.listImp(lines)
out2 = f'List implementation: {out2}'
o2 = open('output2.txt','w')
o2.write(out2)


#BFS
f3 = open('input3.txt','r')
info = f3.readlines()
lines1 = []
for item in info[1:]:
  lines1.append(item.split())
node = int(info[0])
Graph3 = Graph(node)
out3 = Graph3.listImp(lines1)
o3 = open('output3.txt','w')
o3.write(str(Graph3.BFS(out3, '1', '12', Graph3.visitedBFS, Graph3.q)))


#DFS
f4 = open('input4.txt','r')
info = f4.readlines() 
lines2 = []
for item in info[1:]:
  lines2.append(item.split())
node1 = int(info[0])
Graph4 = Graph(node1)
out4 = Graph4.listImp(lines2)
o4 = open('output4.txt','w')
o4.write(str(Graph4.DFS(out4, '12', Graph4.visitedDFS, Graph4.printed, Graph4.resultDFS)))


#function for converting directed graph format to undirected
def biGraph(graph):
  adj = {}

  #copying dict
  for key, val in graph.items():
    if key not in adj.keys():
      adj[key] = []
      for i in val:
        if i not in adj[key]:
          adj[key].append(i)
    else:
      for i in val:
        if i not in adj[key]:
          adj[key].append(i)

  #converting it to directed
  for key, val in graph.items():
    for n in val:
      if n not in adj.keys():
        adj[n] = []
        adj[n].append(key)
      else:
        if key not in adj[n]:
          adj[n].append(key)
    
  return adj

#Task 4
f5 = open('input5.txt', 'r')
info = f5.readlines()
noOfGraphs = int(info[0])
info2 = []
for item in info[1:]:
  info2.append(item.split())

o5 = open('output5.txt','w')
c= 0
for times in range(noOfGraphs):
  noOfNodes = int(info2[c][0])
  noOfEdges = int(info2[c][1])
  tempGraph = Graph(noOfNodes,noOfEdges)
  graphInfo = info2[c+1:c+1+noOfEdges]
  graphDict = tempGraph.listImp(graphInfo)
  graphDict = biGraph(graphDict)
  nBridges = len(tempGraph.shortestPath(graphDict, info2[c+1][0], info2[c][0]))-1
  o5.write(str(nBridges)+'\n')
  c += noOfEdges+1

